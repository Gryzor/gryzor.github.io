---
layout: post
title: "Unit Testing is Easier Than You Think"
date: 2019-04-01 12:51:34
categories:
navtab: blog
---

<p>I am ashamed to admit how many years I avoided incorporating unit tests into my iOS projects. The simple truth is that I was afraid of what I didn&rsquo;t know. I don&rsquo;t have a CS degree. I never studied programming formally. The terminology itself is intimidating. What is a unit? How do I know if my app has units in it? What does it mean to test them? Not understanding what they are or even what good unit tests look like, my anxiety filled the gaps in my knowledge with frightening mental imagery.</p>

<p>After struggling with them for a few years, and after finding the occasional inspiring tech talk, I have come to understand that not only is unit testing not scary, but in fact <em>good</em> unit testing is surprisingly easy. The simplest and best unit test looks exactly like this:</p>

<pre>
XCTAssertEqual(actual, expected)
</pre>

<p>That&rsquo;s it. A straightforward comparison of some unknown value against what you expect that value to be. The goal with unit testing is to write simple, direct assertions like that one. Every other choice you make is just a means to that end. To see how, first let&rsquo;s widen our field of vision to the code surrounding that assertion:</p>

<pre>
let input = ... // hard-coded inputs
let actual = SomeWidget().doSomething(with: input)
let expected = ... // hard-coded output
XCTAssertEqual(actual, expected)
</pre>

<p>A good unit test answers the question, &ldquo;When I pass something into this other thing, what value do I get out?&rdquo; Answering that question is easier if your input and expected output are written using simple, hard-coded constants. Unlike writing regular code, when you&rsquo;re writing a unit test, using hard-coded data is mandatory. Swift literals are your friends. You jot down some hard-coded input values, and also a hard-coded expected output value. Sandwiched in the middle is the behavior you&rsquo;re testing. Imagine if you wanted to test <code>String.lowercased()</code>:</p>

<pre>
let input = "unIT TesTING Is NoT SO BAD"
let actual = input.lowercased()
let expected = "unit testing is not so bad"
XCTAssertEqual(actual, expected)
</pre>

<p>I&rsquo;m calling a method called <code>lowercased()</code>. I&rsquo;m passing a string into it (<code>input</code>) and I&rsquo;m getting another string out of it (<code>actual</code>). I hope that the returned value is the same as another string (<code>expected</code>). By using string literals (instead of, say, dynamic values obtained from a networked resource), you&rsquo;ve eliminated unpredictability from the test. There&rsquo;s now only a single variable (in the algebraic sense) at play, the behavior of <code>lowercased()</code>. This is a good unit test.</p>

<p>This may strike you as overly simplistic, but I assure you it isn&rsquo;t. Even the most complex behaviors in your app can be tested in this manner. If you have some dark corner of your app that you wish had unit tests, start by building a mental model of the problem that&rsquo;s oriented towards that <code>XCTAssert</code> assertion you&rsquo;re going to write. Say you want to add unit tests to some code that interacts with a web service. You have a class that looks like this:</p>

<pre>
class APIManagerHamburgerHelper {
    func getUser(withId id: String, completion: @escaping (Result<user apierror>) -&gt; Void) {...}
}
</user></pre>

<p>Right now there&rsquo;s no way to unit test that <code>getUser</code> method, not in the way that I&rsquo;m advocating. There are several things hindering you. The method has no return value. It requires making a roundtrip request to an actual server. There are many jobs hiding inside the implementation of that method: building a URL request, evaluating a URLSession response envelope (response, data, and error), decoding JSON-encoded data, mapping any error along the way to your <code>APIError</code> type. Each of these hidden jobs is itself something that needs unit test coverage. To test them, you&rsquo;ll need to expose those jobs in a form that is &ldquo;shaped&rdquo; like the <code>.lowercased()</code> example above. There&rsquo;s no one single way to do this, but here&rsquo;s a rough example. You can break out these jobs into a single-purpose utilities:</p>

<pre>
struct URLRequestBuilder {
    func getUserRequest(userId: String) -&gt; URLRequest
}

struct URLResponseEnvelopeEvaluator {
    struct Success: Equatable {
        let response: HTTPURLResponse
        let data: Data
    }

    struct Failure: Swift.Error, Equatable {
        let response: URLResponse?
        let error: APIError?
    }

    typealias Result = Result&lt;Success, Failure&gt;

    func evaluate(data: Data?, response: URLResponse?, error: Error?) -&gt; Result {...}
}

struct User: Decodable {
    let id: String
    let name: String
    let displayName: String
}
</pre>

<p>The knowledge of how to implement each of these jobs (building requests, evaluating responses, parsing data) has been extracted out of the untestable <code>getUser</code> method and into discrete types that lend themselves to straightforward unit tests. Testing the request builder might look something like this:</p>

<pre>
let id = "abc"
let actual = URLRequestBuilder().buildGetUserProfileRequest(userId: id)
let expected: URLRequest = {
    let url = URL(string: "https://baseurl.com/user/\(id)")!
    var request = URLRequest(url: url)
    request.addValue("foo", forHTTPHeaderField: "Bar")
    return request
}()
XCTAssertEqual(actual, expected)
</pre>

<p>Note how the input value and expected output value are all written using hard-coded constants as possible. As with all good unit tests, we pass hard-coded input into the member being tested, and compare the actual output against a hard-coded expected output value. Because inputs and expected outputs are hard-coded, we can write unit tests to cover any imaginable scenario. Perhaps you want to test a specific error pathway, what happens when the web service replies with a 401 status code. We set up the input values to closely reflect what a URLSession would actually present to the developer in a completion block:</p>

<pre>
let data: Data? = nil
let response = HTTPURLResponse(
    url: URL(string: "https://baseurl.com/user/abc")!,
    statusCode: 401,
    httpVersion: "1.0",
    headerFields: nil
)
let error = NSError(
    domain: NSURLErrorDomain,
    code: 401,
    userInfo: ["foo": "bar"]
)
</pre>

<p>Then we use those values as inputs to the method being unit tested, as well as to the expected result (where applicable):</p>

<pre>
let actual = URLResponseEnvelopeEvaluator().evaluate(
    data: data,
    response: response,
    error: error
)
let expected: URLResponseEnvelopeEvaluator.Result = .failure(Failure(
    response: response,
    error: .authenticationError401(error)
))
XCTAssertEqual(actual, expected)
</pre>

<p>In all the foregoing examples, no matter how hairy the subject matter, all the unit tests take the same shape:</p>

<ul><li>define input</li>
<li>pass input into tested member, getting actual output</li>
<li>define expected output</li>
<li>compare the actual and expected outputs</li>
</ul><p>This simple, repeatable pattern is what makes good unit tests &ldquo;easy&rdquo;. The hardest part isn&rsquo;t writing the tests themselves, but rather structuring your code so that the behaviors are <em>unit-testable</em> in the first place. Doing that takes experience and much trial-and-error. That effort will come more easily to you once you have internalized the essential simplicity of a good unit test.</p>

<p>If you would like to learn more about refactoring your code for unit testing, I have a screencast <a href="https://thefrontier.bignerdranch.com/screencasts/unit-testing-what-why-how">on Big Nerd Ranch&rsquo;s The Frontier</a> with some live coding examples that you may find helpful.</p>